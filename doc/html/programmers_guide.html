<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>R | API+: Programmers&#39; Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Programmers' Guide </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="pg_doc_info"></a>
Document Information</h2>
<p>This document and the Software Products that it describes are protected by copyright law and international treaties. Unauthorized use, reproduction or distribution of this document, or any portion of it, may result in severe civil and criminal penalties, and will be prosecuted to the maximum extent possible under the law.</p>
<p>The Software Products described in this document are licensed strictly in accordance with a separate Software System License Agreement, granted by Rithmic, LLC, which contains restrictions on use, reverse engineering, disclosure, confidentiality and other matters.</p>
<p>Information in this document, as well as the features and specifications of the Software Products described by this document, are subject to change without notice. Rithmic, LLC, makes no claims as to the accuracy or completeness of any information contained herein. Rithmic, LLC, is not responsible for any typographical errors contained in this document.</p>
<p>Copyright (c) 2020 Rithmic, LLC.</p>
<p>Rithmic&trade;, R | Trade Execution Platform&trade;, R | Trader&trade;, R | Trader Pro&trade;, R | Manager&trade;, and R | API&trade;, are trademarks of Rithmic, LLC, in the United States, other countries, or both.</p>
<hr/>
<h2><a class="anchor" id="pg_toc"></a>
Table Of Contents</h2>
<ul>
<li><a class="el" href="programmers_guide.html#pg_preface">Preface</a> </li>
<li><a class="el" href="programmers_guide.html#pg_what_is_rtrade">What is R | Trade Execution Platform?</a> </li>
<li><a class="el" href="programmers_guide.html#pg_what_is_rapi">What is R | API?</a> </li>
<li><a class="el" href="programmers_guide.html#pg_os_platforms">Operating Systems, Frameworks, Compilers and Target Platforms</a> </li>
<li><a class="el" href="programmers_guide.html#pg_file_list">Installation and File List</a> </li>
<li><a class="el" href="programmers_guide.html#pg_building_cpp">Building A C++ Rithmic API Application</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_building_cpp_windows">Building C++ On Windows Using Visual Studio</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_building_cpp_linux">Building C++ On Linux Using GCC/g++</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_building_cpp_darwin">Building C++ On Darwin Using GCC/g++</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_classes">Organization Of Rithmic API Classes</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_class_categories">There are three main categories of classes in the Rithmic APIs :</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_class_dump_method">The dump() Method</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_configuring">Configuring A Rithmic API Application</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_configuring_configuration_files">Configuration Files</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_configuring_conformance">Conformance and Fees</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_max_session_count">Max Session Counts</a> </li>
<li><a class="el" href="programmers_guide.html#pg_plugins">Using R | Trader Pro as a Plug-In Host</a> </li>
<li><a class="el" href="programmers_guide.html#pg_environments">Connecting to Multiple Rithmic Systems Simultaneously Using Environments</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_environments_background">Background</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_multiple_environments">Multiple Environments</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_interface">Programming Interface</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_single_environment">Prior Behavior With A Single Environment</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_comments">Comments</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_connections">Connections</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_cnnct_pts">Connect Points</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_aggregated_data">Aggregated Data Market Data</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_locations">Gateways and Points-Of-Presence</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_best_practices">Best Practices</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_mgmt">Connection Management</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_strings_cpp">Strings And tsNCharcb (C++ Only)</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_strings_why_tsncharcb">Why use the tsNCharcb for representing strings?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_cpp_to_tsnchar">How does one convert a C++ string into a tsNCharcb?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_tsnchar_to_cpp">How does one convert a tsNCharcb into a C++ string?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_tsnchar_init">Do I need to initialize both the pData and the iDataLen of each tsNCharcb?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_memory">Who owns the memory pointed to by tsNCharcb::pData?</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_timestamps">On Timestamps (ssboe, usecs and nsecs)</a> </li>
<li><a class="el" href="programmers_guide.html#pg_threads">On Threads</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_threads_cpp">Threads In C++ API</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_threads_dotnet">Threads In .NET API</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_errors">Error Handling Conventions</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_error_codes">Error Codes</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_exception_classes">Exception Classes</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_error_why">Why And Where Errors Might Occur</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_aicode_out_param">The 'aiCode' Out Parameter (C++ only)</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_error_examples">Examples Of Errors</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_errors_in_user_callbacks">Error Handling In User Implemented Callbacks</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_basic_steps">Basic Steps of a Program that Incorporates R | API</a> </li>
<li><a class="el" href="programmers_guide.html#pg_bug_reports">Feedback And Bug Reports</a> </li>
<li><a class="el" href="programmers_guide.html#pg_contact_info">Contact Info</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="pg_preface"></a>
Preface</h2>
<p>This Programmer's Guide is a high level description of R | API along with technical background information. It is intended for users new to Rithmic's APIs looking for a basic overview. For additional information please consult other resources, such as documentation for each class/method, sample code, and/or the FAQ.</p>
<p>Suggestions for improvement of this document are always welcome.</p>
<hr/>
<h2><a class="anchor" id="pg_what_is_rtrade"></a>
What is R | Trade Execution Platform?</h2>
<p>The R | Trade Execution Platform is software that implements a trading platform with market data, risk management and order handling functionality. There are many instances of the R | Trade Execution Platform. Each instance is referred to as a "system", or "environment". Some are private systems, and others exist under different brands, or are available through a particular FCM or broker.</p>
<p>Each of these systems appear as values in the "System" drop down box of the R | Trader login screen. Programmatically, one specifies different parameters to the REngine constructor to access different Rithmic systems.</p>
<p>Each of these systems serves a different purpose. For example,</p>
<p><b>Rithmic Test :</b> The test environment is called Rithmic Test. Exchanges typically provide a test environment in which test orders are placed against a test matching engine, and resultant market data is published. This environment uses these test environments. This environment can appear strange because the market data can be unrealistic, and is often driven by what (test) orders are resting on the matching engine.</p>
<p><b>Rithmic 01 :</b> There is a production environment called Rithmic 01 which uses live market data and live matchine engines.</p>
<p><b>Rithmic Paper Trading :</b> This environment uses live market data, but with a simulator for a matching engine.</p>
<p>Each installation has its own administrative organizations responsible for creating or maintaining that installation's user ids and trading accounts. Typically, whoever issues a user id also handles the administration of that user id and any associated trading accounts. This administrative role includes configuring market data entitlements and risk management settings for trading accounts. A user id must be entitled to market data from a particular exchange to receive the market data stream. If a trading account does not have risk management settings configured for a particular instrument or set of instruments, users will not be able to place orders for those instruments on that account. Each user id has the ability to trade on zero to many trading accounts.</p>
<hr/>
<h2><a class="anchor" id="pg_what_is_rapi"></a>
What is R | API?</h2>
<p>R | API is collection of libraries and configuration files and a programmatic interface for accessing services provided by Rithmic's R | Trade Execution Platform. By incorporating R | API into your software, you (and your software) may retrieve real-time and historical market data and reference data for financial securities and for option, commodity and foreign exchange contracts and you may place and manage orders for those securities and contracts. R | API also allows you to obtain account and margin balances, order history and p&amp;l and position information. The specific accounts you may view and access, the instruments you may trade, the market data you may view and the number of concurrent connections you may maintain to R | Trade Execution Platform is subject to restrictions and permissions established by your Futures Commission Merchant (FCM), your Broker-Dealer or your Introducing Broker (IB), as the case may be.</p>
<h3><a class="anchor" id="pg_cpp_vs_dotnet"></a>
C++ vs. .NET</h3>
<p>There are two compilations of R | API, one for C++ and the other for .NET. The interface for the C++ compilation does not make use of 'modern' C++ and should be accessible to anyone with knowledge of C or 'classic' C++. Furthermore, the C++ classes do not necessarily adhere to standard STL conventions and should be used with care in an STL environment.</p>
<p>As much as possible the feature set and interface exposed by both compilations are the same, but because they are built on different underlying libraries, some differences remain, including obvious differences such as the use of properties in .NET as well as more subtle differences such as the threading model used for handling events. In general, the behavior of the two compilations is kept as close as possible.</p>
<p>The .NET compilation of R | API is a pure .NET library. It does not contain unmanaged code.</p>
<h3><a class="anchor" id="pg_which_api_for_me"></a>
R | API+ and R | Diamond Cutter</h3>
<p>There are two variations of R | API, both using the same basic object model. R | API+ provides trading infrastructure services. R | Diamond Cutter includes everything R | API+ has, with additional functionality for ultra low latency applications. R | Diamond Cutter is only offered in C++.</p>
<p>R | API (no plus) has been discontinued.</p>
<hr/>
<h2><a class="anchor" id="pg_os_platforms"></a>
Operating Systems, Frameworks, Compilers and Target Platforms</h2>
<p>The Rithmic APIs make use of a set of libraries licensed from Omnesys Technologies, Inc. These libraries and the Rithmic APIs have been built on several operating systems and frameworks with specific compilers for use on specific target platforms as indicated below. Please be sure to build your software using only the compilers and frameworks listed below on machines running the associated operating systems. Support will not be provided for software built any other way and support will not be provided for software run on any other operating systems and/or frameworks. Also, support will not be provided for software run on any operating system and/or framework emulators.</p>
<h3><a class="anchor" id="pg_cpp_compilation"></a>
The C++ compilation of Rithmic APIs have been built as follows:</h3>
<center> <table class="doxtable">
<tr>
<th>Build Operating System </th><th>Compiler </th><th>Target Platform  </th></tr>
<tr>
<td>Darwin 10.5.0 for darwin-10 (64-bit darwin) </td><td>gcc/g++ 4.1.2 </td><td>Darwin 10.5.0 for darwin-10 (64-bit darwin)  </td></tr>
<tr>
<td>RHEL 6.3 for linux-gnu-2.6.32-x86_64 (64-bit linux) </td><td>gcc/g++ 4.4.6 </td><td>RHEL 6.3 for linux-gnu-2.6.32-x86_64 (64-bit linux)  </td></tr>
<tr>
<td>RHEL 7.0 for linux-gnu-3.10.0-x86_64 (64-bit linux) </td><td>gcc/g++ 4.8.2 </td><td>RHEL 7.0 for linux-gnu-3.10.0-x86_64 (64-bit linux)  </td></tr>
<tr>
<td>Windows 10 Professional (64-bit) </td><td>Visual Studio 2015 Professional </td><td>Windows 10 Professional (32-bit)  </td></tr>
<tr>
<td>Windows 10 Professional (64-bit) </td><td>Visual Studio 2015 Professional </td><td>Windows 10 Professional (64-bit)  </td></tr>
</table>
</center><hr/>
<h2><a class="anchor" id="pg_file_list"></a>
Installation and File List</h2>
<p>Rithmic APIs are distributed as a compressed set of files (a zip archive) which can be extracted using standard utilities. The top level directory within the zip archive is the version number of the API. Beneath this directory are documentation and assorted files necessary for building programs that incorporate the API.</p>
<h3><a class="anchor" id="pg_cpp_files"></a>
Files in the C++ Compilation</h3>
<center> <table class="doxtable">
<tr>
<th>File or Sub-directory </th><th>Description  </th></tr>
<tr>
<td>darwin/lib/ </td><td>Directory containing libraries to link against when building for darwin.  </td></tr>
<tr>
<td>documentation.html </td><td>Start page for html documentation. (Redirects to doc/html/index.html)  </td></tr>
<tr>
<td>etc/ </td><td>Directory containing SSL files.  </td></tr>
<tr>
<td>include/ </td><td>Directory containing the include file.  </td></tr>
<tr>
<td>linux-gnu-2.6.32-x86_64/lib/ </td><td>Directory containing libraries to link against when building for linux-gnu-2.6.32-x86_64.  </td></tr>
<tr>
<td>linux-gnu-3.10.0-x86_64/lib/ </td><td>Directory containing libraries to link against when building for linux-gnu-3.10.0-x86_64.  </td></tr>
<tr>
<td>samples/ </td><td>Directory containing sample code.  </td></tr>
<tr>
<td>win10/lib/ </td><td>Directory containing libraries to link against when building for Windows 10.  </td></tr>
<tr>
<td>Release.Notes </td><td>Change log  </td></tr>
</table>
</center><hr/>
<h2><a class="anchor" id="pg_building_cpp"></a>
Building A C++ Rithmic API Application</h2>
<p>In the samples directory there are VS2010 and VS2015 sample solutions. Also, in the comments at the top of each source file, there is a compile/link line one can use in unix-like operating systems. There is also information about configuring, building and running the sample code in the <a class="el" href="quick_start.html">Quick Start</a>.</p>
<p>To compile an application which uses a Rithmic API library, your compiler must know the location of the header file. The header file name will be "RApi.h", "RApiPlus.h" or "RDiamondApi.h", depending on which version you are using.</p>
<h3><a class="anchor" id="pg_building_cpp_windows"></a>
Building C++ On Windows Using Visual Studio</h3>
<h4><a class="anchor" id="pg_compiling_windows"></a>
Compiling On Windows</h4>
<p>Code should be generated with the run-time libraries set to Multi-threaded (/MT), Multi-threaded Debug (/MTd), Multi-threaded DLL (/MD), or Multi-threaded Debug DLL (/MDd). Code should be compiled with run-time type information enabled (/GR).</p>
<p>If you are compiling the sample code, you should define "WinOS".</p>
<h4><a class="anchor" id="pg_linking_windows"></a>
Linking On Windows</h4>
<p>To link an application under Windows, you will need to link with a number of libraries included in the <a class="el" href="namespaceRApi.html">RApi</a> package under the win7\lib directory for Visual Studio 2010 libraries, and the win10\lib directory for Visual Studio 2015 libraries. All the libraries are named with different suffixes indicating the code generation flag used when compliling : </p>
<ul>
<li>
*_mdd.lib indicates /MDd on 32-bit platforms </li>
<li>
*_md.lib indicates /MD on 32-bit platforms </li>
<li>
*_mtd.lib indicates /MTd on 32-bit platforms </li>
<li>
*_mt.lib indicates /MT on 32-bit platforms </li>
<li>
*_mdd64.lib indicates /MDd on 64-bit platforms </li>
<li>
*_md64.lib indicates /MD on 64-bit platforms </li>
<li>
*_mtd64.lib indicates /MTd on 64-bit platforms </li>
<li>
*_mt64.lib indicates /MT on 64-bit platforms </li>
</ul>
<p>So, if the code was compiled using Multi-threaded DLL (/MD) for the 32-bit platform, the following libraries would be used to link :</p>
<ul>
<li>
kit_md.lib </li>
<li>
apistb_md.lib </li>
<li>
api_md.lib </li>
<li>
OmneEngine_md.lib </li>
<li>
OmneChannel_md.lib </li>
<li>
OmneStreamEngine_md.lib </li>
<li>
RApi_md.lib (or RApiPlus_md.lib or RDiamondApi_md.lib) </li>
</ul>
<p>You will also need these ssl libraries from OpenSSL (also included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
libeay32_md.lib </li>
<li>
ssleay32_md.lib </li>
</ul>
<p>And these zlib libraries (also included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
zlib_md.lib </li>
</ul>
<p>You may also need to specify these system libraries :</p>
<ul>
<li>
ws2_32.lib </li>
<li>
iphlpapi.lib </li>
<li>
psapi.lib </li>
</ul>
<p>If you are using the /NODEFAULTLIB switch, you will need the following libraries:</p>
<ul>
<li>
kernel32.lib </li>
<li>
gdi32.lib </li>
<li>
advapi32.lib </li>
<li>
user32.lib </li>
</ul>
<p>You also need to link with The C (and possibly C++) runtime libraries. The C runtime library names have changed between Visual Studio 2010 and Visual Studio 2015.</p>
<p>For Visual Studio 2010 C runtime libraries, use :</p>
<ul>
<li>
msvcrt.lib (/MD) or libcmt.lib (/MT) or msvcrtd.lib (/MDd) or libcmtd.lib (/MTd) </li>
<li>
OLDNAMES.lib </li>
</ul>
<p>For Visual Studio 2015 C runtime libraries use :</p>
<ul>
<li>
ucrt.lib (/MD) or libucrt.lib (/MT) or ucrtd.lib (/MDd) or libucrtd.lib (/MTd) </li>
<li>
vcruntime.lib (/MD) or libvcruntime.lib (/MT) or vcruntimed.lib (/MDd) or libvcruntimed.lib (/MTd) </li>
<li>
msvcrt.lib (/MD) or libcmt.lib (/MT) or msvcrtd.lib (/MDd) or libcmtd.lib (/MTd) </li>
<li>
legacy_stdio_definitions.lib </li>
<li>
OLDNAMES.lib </li>
</ul>
<p>If you are using the standard C++ runtime library, you may need the following libraries:</p>
<ul>
<li>
msvcprt.lib (/MD) or  </li>
<li>
libcpmt.lib (/MT) </li>
<li>
msvcprtd.lib (/MDd) or  </li>
<li>
libcpmtd.lib (/MTd) </li>
</ul>
<hr/>
<h3><a class="anchor" id="pg_building_cpp_linux"></a>
Building C++ On Linux Using GCC/g++</h3>
<p>Each of the sample code source files includes in the comments at the top of the file, a build line for that sample. You shouldn't need to modify it if your pwd is the ./samples directory and you are using the RApiPlus.cpp package..</p>
<p>If you are using the RApi.cpp or RDiamondApi.cpp package, you will have to edit the name of the <a class="el" href="namespaceRApi.html">RApi</a> library you link against.</p>
<h4><a class="anchor" id="pg_compiling_linux"></a>
Compiling On Linux</h4>
<p>Internal testing is done using the following compiler flags : </p>
<ul>
<li>
-DLINUX </li>
<li>
-D_REENTRANT </li>
<li>
-Wall </li>
<li>
-Wno-sign-compare </li>
<li>
-Wno-write-strings </li>
<li>
-Wpointer-arith </li>
<li>
-Winline </li>
<li>
-Wno-deprecated </li>
<li>
-fno-strict-aliasing </li>
</ul>
<h4><a class="anchor" id="pg_linking_linux"></a>
Linking On Linux</h4>
<p>To link an application under linux, you will need to link with the following libraries (included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
RApi-optimize (or RApiPlus-optimize or RDiamondApi-optimize) </li>
<li>
OmneStreamEngine-optimize </li>
<li>
OmneChannel-optimize </li>
<li>
OmneEngine-optimize </li>
<li>
_api-optimize </li>
<li>
_apipoll_stubs-optimize </li>
<li>
_kit-optimize </li>
</ul>
<p>For RHEL 6, you may also need to link with the following system, SSL and z libraries. Some are included in the zip file in case one wishes to use them. :</p>
<ul>
<li>
ssl (included)  </li>
<li>
crypto (included)  </li>
<li>
krb5 </li>
<li>
k5crypto </li>
<li>
com_err </li>
<li>
resolv </li>
<li>
m </li>
<li>
pthread </li>
<li>
rt </li>
<li>
z </li>
</ul>
<p>This compile/link line for SampleMD.cpp using R | API+ works on 64-bit linux of the 2.6.32 kernal (RHEL 6.x). You shouldn't need to modify anything if your pwd is the ./samples directory. </p>
<div class="fragment"><pre class="fragment">
g++ -O3 -DLINUX -D_REENTRANT -Wall -Wno-sign-compare -Wno-write-strings -Wpointer-arith -Winline -Wno-deprecated -fno-strict-aliasing -I../include -o SampleMD ../samples/SampleMD.cpp -L../linux-gnu-2.6.32-x86_64/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib64 -lz -L/usr/kerberos/lib -lkrb5 -lk5crypto -lcom_err -lresolv -lm -lpthread -lrt
</pre></div><p>For RHEL 7, the list is similar, but shorter. If the linker claims it "cannot find -ld", you may need to install the package "libzip-devel".</p>
<ul>
<li>
ssl (included)  </li>
<li>
crypto (included)  </li>
<li>
pthread </li>
<li>
rt </li>
<li>
z </li>
</ul>
<p>This compile/link line for SampleMD.cpp using R | API+ works on 64-bit linux of the 3.10.0 kernal (RHEL 7.x). You shouldn't need to modify anything if your pwd is the ./samples directory. </p>
<div class="fragment"><pre class="fragment">
g++ -O3 -DLINUX -D_REENTRANT -Wall -Wno-sign-compare -Wno-write-strings -Wpointer-arith -Winline -Wno-deprecated -fno-strict-aliasing -I../include -o SampleMD ../samples/SampleMD.cpp -L../linux-gnu-3.10.0-x86_64/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib64 -lz -lpthread -lrt -ldl
</pre></div><hr/>
<h3><a class="anchor" id="pg_building_cpp_darwin"></a>
Building C++ On Darwin Using GCC/g++</h3>
<h4><a class="anchor" id="pg_compiling_darwin"></a>
Compiling On Darwin</h4>
<p>Internal testing is done using the following compiler flags : </p>
<ul>
<li>
-DMacOS </li>
<li>
-D_REENTRANT </li>
<li>
-Wall </li>
<li>
-Wno-sign-compare </li>
<li>
-fno-strict-aliasing </li>
<li>
-Wpointer-arith </li>
<li>
-Winline </li>
<li>
-Wno-deprecated </li>
<li>
-Wno-write-strings </li>
</ul>
<h4><a class="anchor" id="pg_linking_darwin"></a>
Linking On Darwin</h4>
<p>To link an application under Darwin, you will need to link with the following libraries (included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
RApi-optimize (or RApiPlus-optimize or RDiamondApi-optimize) </li>
<li>
OmneStreamEngine-optimize </li>
<li>
OmneChannel-optimize </li>
<li>
OmneEngine-optimize </li>
<li>
_api-optimize </li>
<li>
_apipoll_stubs-optimize </li>
<li>
_kit-optimize </li>
</ul>
<p>You may also need to link with the following system, SSL and z libraries. Some are included in the <a class="el" href="namespaceRApi.html">RApi</a> package in case one wishes to use them. :</p>
<ul>
<li>
ssl (included)  </li>
<li>
crypto (included)  </li>
<li>
krb5 </li>
<li>
resolv </li>
<li>
m </li>
<li>
pthread </li>
<li>
z </li>
</ul>
<p><a class="anchor" id="pg_darwin_make"></a> This compile/link line for SampleMD.cpp works on (64-bit) darwin. You shouldn't need to modify anything if your pwd is the ./samples directory. </p>
<div class="fragment"><pre class="fragment">
g++ -O3 -DMacOS -D_REENTRANT -Wall -Wno-sign-compare -fno-strict-aliasing -Wpointer-arith -Winline -Wno-deprecated -Wno-write-strings -I../include -o ./SampleMD ../samples/SampleMD.cpp -L../darwin-10/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib -lz -L/usr/lib -lkrb5 -lresolv -lm -lpthread
</pre></div><hr/>
<h2><a class="anchor" id="pg_classes"></a>
Organization Of Rithmic API Classes</h2>
<h3><a class="anchor" id="pg_class_categories"></a>
There are three main categories of classes in the Rithmic APIs :</h3>
<ul>
<li>The first category contains the 'action' class. For R | API it is REngine. All actions are initiated by calls to methods of that class. The methods of REngine represent the available services from the infrastructure.</li>
</ul>
<ul>
<li>The second category is for callback classes. Rithmic APIs typically request network services asynchronously. These requests are processed by the infrastructure and the responses are conveyed via methods of callback classes. There are a small number of callback classes : <ul>
<li>
AdmCallbacks for administrative callbacks, and </li>
<li>
RCallbacks for REngine callbacks (primary callback class for R | API). </li>
</ul>
</li>
</ul>
<ul>
<li>The third category is for 'Info' classes, which convey information specific to a particular callback method. These class names typically end in 'Info', such as RefDataInfo.</li>
</ul>
<p>The names of an REngine method, its corresponding callback method, and the class used to convey the callback specific information are usually, but not always, similar.</p>
<p>For example :</p>
<ul>
<li>REngine::replayPnl() - Requests a snapshot of pnl information for a given account. </li>
<li>RCallbacks::PnlReplay() - The callback method invoked when the response to the request has been received and processed. </li>
<li>PnlReplayInfo - The actual pnl information being returned.</li>
</ul>
<p>Subscriptions are a notable exception to the naming conventions. Calls to REngine::subscribe() and REngine::subscribeOrder() can result in a number of different callbacks being invoked.</p>
<h3><a class="anchor" id="pg_class_dump_method"></a>
The dump() Method</h3>
<p>The dump() method that all the Info classes support is a utility method that prints the object contents to stdout. It is deprecated and may be removed in a future release.</p>
<hr/>
<h2><a class="anchor" id="pg_configuring"></a>
Configuring A Rithmic API Application</h2>
<p>A Rithmic API application must connect to at least one Rithmic system. (It is possible to connect to more than one system, but that is a more advanced topic not addressed here.) The system to which an REngine instance connects to depends on the configuration passed to the REngine constructor by REngineParams. Along with the REngine constructor, the REngine::login() routine indicates where (within the Rithmic system) the Rithmic API application will connect, and which what credentials.</p>
<h3><a class="anchor" id="pg_configuring_configuration_files"></a>
Configuration Files</h3>
<p>Settings to various Rithmic systems are distributed by the Rithmic operations team in 'connection_params.txt' files, usually made available in your download directory. These files contain information that is needed by the REngine constructor and the REngine::login() routine to connect to a particular Rithmic system. The prefix of the file name should identify the Rithmic system, and the version number in the file name is an 'as-of' version. It is possible that the version of your R | API is greater than the configuration file's 'as-of' version. The file name might also identify the gateway represented by the configuration. A gateway is a point-of-presence for a Rithmic system. For example, Rithmic 01 has gateways in North America, South America, Europe and Asia. Sometimes users find that one gateway (often geographically closer) is more reliable than another.</p>
<p>The sample code (e.g. SampleMD or SampleOrder) is hard-coded to connect to Rithmic Test via our Orangeburg gateway. The Rithmic Test configuration files are also available in each download directory. The file name as of this writing is "Rithmic_Test_Orangeburg_rapi_connection_params_10.5.0.0.txt". One can review the relationship between this configuration file and the sample code to see how the file contents map into code.</p>
<p>Rithmic systems and their associated configuration information can be added, modified, or removed from time to time. Vendors of trading applications built on R | API can find it useful to support the ability to dynamically incorporate these kinds of configuration changes.</p>
<h3><a class="anchor" id="pg_configuring_conformance"></a>
Conformance and Fees</h3>
<p>An R | API application must go through conformance before the connection_params text file containing settings for systems other than Rithmic Test are made available. Most environments requiring conformance make use of live market data and/or live accounts.</p>
<p>Associated with live data or trading can be fees. Fees can vary greatly depending on how many concurrent market data connections a user is entitled to (see <a class="el" href="programmers_guide.html#pg_max_session_count">Max Session Counts</a>), as well as the number of exchanges for which market data is entitled. For users writing their own apps, it is recommended that when going through conformance, you also consult with your broker or fcm to understand any fees associated with using the R | API with these additional Rithmic systems.</p>
<p>To begin conformance, please contact Rithmic at <a href="mailto:rapi@rithmic.com">rapi@rithmic.com</a>.</p>
<hr/>
<h2><a class="anchor" id="pg_max_session_count"></a>
Max Session Counts</h2>
<p>The configuration of each user's maximum number of concurrent connections is called the Max Session Count. A user has a Max Session Count for orders, and another Max Session Count for market data. One can view their max session counts using R | Trader Pro by opening the File menu, and selecting User Profile.</p>
<p>When a user exceeds their max session count, the infrastructure will automatically disconnect that user's oldest login session. As a courtesy, the infrastructure will alert the client application prior to severing the connection. This alert appears as a Forced Logout alert in RCallbacks::Alert(). When an RAPI client receives a Forced Logout alert, it will log out entirely from the infrastructure, not just the connection on which the forced logout alert arrived.</p>
<p>The Max Session Counts apply per connection. The market data count applies to the market data connect point and to the history connect point. The orders count applies to the trading system connect point and the pnl connect point. So, for example, if a user has a max session count of 2 for market data, they can connect twice to the market data connect point, and twice to the history connect point. If they connect a third time to the market data connect point, their oldest login session will receive a forced logout alert and then will either log out gracefully (if there is time), or have it's connection severed by the infrastructure.</p>
<hr/>
<h2><a class="anchor" id="pg_plugins"></a>
Using R | Trader Pro as a Plug-In Host</h2>
<p>It is possible to configure an R | API app to be a plug-in client of R | Trader Pro. When an R | API app is a plug-in client, it will connect to R | Trader Pro as its market data and historical data source. This plug-in arrangement allows for a single market data session of R | Trader Pro to be used for multiple R | API plug-in apps.</p>
<p>Use of plug-in functionality conserves the number of concurrent market data connections a user is entitled to, which can reduce applicable market data fees. (See <a class="el" href="programmers_guide.html#pg_max_session_count">Max Session Counts</a>.) Many users have a max session count for market data of one, and a higher max session count for orders. This allows them to use one connection (plug-in host + N plug-in clients) for market data, and multiple direct connections for orders.</p>
<p>Below are the steps to run a plug-in host and client :</p>
<p>1. Download, install, and then run R | Trader Pro as a plug-in host. You can get a version from the Rithmic website. Versions 15.x.y.z and below do not support plug-in functionality.</p>
<p>1a. From R | Trader Pro's login screen, enable "Allow Plug-ins". It will turn yellow when enabled. You may need to click on Advanced to get to the "Allow Plug-ins" setting.</p>
<p>1b. Enter your normal credentials for the Orders system and gateway as well as for the Market Data system and gateway. It is possible to mix-and-match which Rithmic system one logs into for orders and for market data.</p>
<p>1c. Using your favorite TCP utility, you can verify that the plug-in host is running by seeing that 127.0.0.1:3010 and 127.0.0.1:3012 are being listened to for TCP.</p>
<p>2. Change the configuration of your RAPI app to use the plug-in.</p>
<p>2a. Define two environment variables before instantiating REngine. RAPI_MD_ENCODING=4 and RAPI_IH_ENCODING=4. In .NET you might use System.SetEnvironmentVariable(). In C++ the environment variables have to be in REngineParams::envp. You should be able to see these environment variables in your RAPI log file.</p>
<p>2b. Use "127.0.0.1:3010" as your MdCnnctPt and "127.0.0.1:3012" as your IhCnnctPt.</p>
<p>2c. When logging into your RAPI app, the credentials used for the MdCnnctPt and IhCnnctPt must match the credentials entered into R | Trader Pro for its Market Data connection.</p>
<hr/>
<h2><a class="anchor" id="pg_environments"></a>
Connecting to Multiple Rithmic Systems Simultaneously Using Environments</h2>
<p>R | API looks for configuration information from environment variables. A properly configured set of environment variables associates itself with a particular Rithmic system. However, it is possible for one instance of REngine to be associated with multiple Rithmic systems. This enables users to connect to one system for their market data, and another system for their trading.</p>
<p>Note : The discussion which follows assumes a familiarity with the idea of environment variables (name value pairs), that exist in operating system process spaces.</p>
<h3><a class="anchor" id="pg_environments_background"></a>
Background</h3>
<p>Historically, environment variables were conveyed to the REngine constructor via REngineParams either as an array of C-style strings (in C++) or as parameters to REngine (in .NET). The environment was not taken directly from the operating system process space to allow for programmers to directly customize the environment used by REngine. With this approach, each instance of REngine was associated with a single environment, and a single Rithmic system.</p>
<h3><a class="anchor" id="pg_environments_multiple_environments"></a>
Multiple Environments</h3>
<p>However, there are cases where one instance of REngine may need to connect to multiple Rithmic systems. For example, a user may have a market data subscription in Rithmic System A, with a trading account on Rithmic System B. Having the ability to connect to A and B simultaneously would remove the need for another (redundant and/or costly) market data subscription in Rithmic System B.</p>
<p>To support these use cases, the REngine class now supports multiple environments. Each environment is keyed with an identifying string. There is a default key for the system environment, taken from REngineParams. When logging in, one can specify which environment to use with a connect point.</p>
<h3><a class="anchor" id="pg_environments_single_environment"></a>
Prior Behavior With A Single Environment</h3>
<p>If there is no need to use multiple environments, one can rely on the REngineParams values and specify an empty string for the environment key when logging in. This approach will mirror behavior prior to the introduction of multiple environment functionality.</p>
<h3><a class="anchor" id="pg_environments_comments"></a>
Comments</h3>
<ul>
<li>
<p class="startli">R | API programmers, especially vendors, may wish to keep any environment-related configurations outside of their application binary, as these configurations can change over time. Configuration files are an example of this approach.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When connecting to a plug-in host, the environment does not matter, as the connect point is on the loopback adapter and does not need to be resolved. However, the user/password credentials must match the credentials entered into the plug-in host.</p>
<p class="endli"></p>
</li>
<li>
Setting an operating system process space's environment variable while an R | API app is running will not cause that environment variable to appear in the default system environment. When in doubt, verify that the desired set of environment variables and values exist using the REngine routines. </li>
</ul>
<h3><a class="anchor" id="pg_environments_interface"></a>
Programming Interface</h3>
<p>Programmers can use the following routines to list/get/set/unset environment variables. These routines require an REngine instance, so a default environment passed via REngineParams will always exist. Each environment is keyed by a string. The default environment has a key of "system".</p>
<dl class="see"><dt><b>See also:</b></dt><dd>REngine::listEnvironments() </dd>
<dd>
REngine::getEnvironment() </dd>
<dd>
REngine::getEnvironmentVariable() </dd>
<dd>
REngine::setEnvironmentVariable() </dd>
<dd>
REngine::unsetEnvironmentVariable()</dd></dl>
<p>NOTE : Currently this interface exists only for the .NET RAPI. Support in the C++ RAPI is forthcoming.</p>
<hr/>
<h2><a class="anchor" id="pg_connections"></a>
Connections</h2>
<p>Applications built on Rithmic APIs establish multiple connections to installations of the Rithmic trading platform. Some connections are transient, while others are persistent. The transient connections can appear as environment variables or values in REngineParams. Persistent connections are specified as connect points.</p>
<h3><a class="anchor" id="pg_cnnct_pts"></a>
Connect Points</h3>
<p><a class="el" href="programmers_guide.html#pg_what_is_rtrade">Above</a>, we learned that there are multiple installations of the R | Trade Execution Platform, i.e. the different Rithmic systems. We also <a class="el" href="programmers_guide.html#pg_environments">learned</a> that each environment is associated with a particular Rithmic system.</p>
<p>A connect point is a logical name for a network address within an installation of an R | Trade Execution Platform. Each connect point exposes a different set of services. More explicitly, the connect point + environment yields an IP and port. The environment drives how the connect point is resolved, so the same connect point string value might resolve differently if paired with a different environment.</p>
<p>Connect points are also where user credentials are submitted. Because a connect point is associated with a particular Rithmic system, the user id and password passed into that connect point must also match the associated Rithmic system. In other words, logging in to a specific system requires an environment, a connect point, a user and a password.</p>
<p>An exception to how credentials are handled is when connecting to a plug-in host. When connecting to a plug-in host, the user id and password must match what was entered for the plug-in host, regardless of the environment specified. Plug-in host connect points differ in that they are in the IP:port form and do not need to be resolved.</p>
<p>Another exception is the administrative connect point specified in REngineParams. The administrative connect point does not use credentials.</p>
<p>The following connect points are used in R | API : </p>
<ul>
<li>
<a class="el" href="classRApi_1_1REngineParams.html#ac5116bd61de4f5e0b87f14e84ebf0b50">RApi::REngineParams::sAdmCnnctPt</a> - The admin connect point is required when instantiating the REngine, and is used to convey administrative alerts. It is not possible to specify a keyed environment. The default system environment is used. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#a62a21989bb9cd742351be803b2dbedf3">RApi::LoginParams::sMdCnnctPt</a> - Connect point to the ticker plant. This connect point is always required when logging in and provides market data services. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#a39807f7c99c5b09b201df6f55e65b727">RApi::LoginParams::sTsCnnctPt</a> - Connect point to the order plant, providing order handling services. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#a76e4ccdec0681d7813158ae74a57f4e6">RApi::LoginParams::sPnlCnnctPt</a> - Connect point to the pnl tree for pnl snapshots and updates. The environment used for this connect point is always the same as the environment used for the order plant. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#ab3d51732601f10b56ddea5a470513fac">RApi::LoginParams::sIhCnnctPt</a> - Connect point to history plant for historical (not real-time) market data. </li>
</ul>
<p>If one does not specify a particular optional connect point, access to the services provided by that segment of R | Trade Execution Platform will be unavailable to the REngine. The most common error returned in this case will be a 'no handle' error.</p>
<p>Connect points available for a particular installation are distributed by the Rithmic operations team in a 'connection_params.txt' file. These text files are generally distributed via the user's download directory on the Rithmic webserver. See the above discussion on <a class="el" href="programmers_guide.html#pg_configuring">Configuring A Rithmic API Application</a> for more information.</p>
<h3><a class="anchor" id="pg_connection_aggregated_data"></a>
Aggregated Data Market Data</h3>
<p>Rithmic installations may also offer aggregated market data feeds. End users with limited end-to-end network bandwidth or other computing limitations may prefer using these aggregated market data feeds for an improved user experience.</p>
<p>With aggregated market data, updates to certain types of data are accummulated where only the most recent version of that data is published. The publishing frequency may depend on the Rithmic system's configuation, but is generally set to 0.25 seconds. So, for example, if the best bid/ask prices or quantities change many times over the 0.25 second interval, only the most recent values are published. There are also types of data which are not aggregated, such as trades. Trades pass through without any aggregation.</p>
<p>To make use of an aggregated market data feed, one would use the market data connect point for the aggregated feed instead of for the normal/raw market data feed. In other words, when logging in, one changes the market data connect point value to switch between aggregated and non-aggregated market data feeds.</p>
<p>Aggregated market data connect point values are also found in the connection_params files.</p>
<h3><a class="anchor" id="pg_connection_locations"></a>
Gateways and Points-Of-Presence</h3>
<p>Some Rithmic installations have multiple "Gateways". A gateway is a geographically local point-of-presence providing access to a particular Rithmic system. There may be multiple gateways to a single Rithmic system. These gateways may be spread throughout the world, such as in North America, South America, Europe and Asia. Some end users find that using a different (perhaps geographically closer?) gateway improves their user experience.</p>
<p>For example, in Europe, an end user might find that the Frankfurt gateway offers the best performance/user experience. The very best performance can be obtained by colocating your program with Rithmic. Colocation services are available from our sister company, <a href="https://theomne.net" target="_blank">TheOmne.net</a>. When you colocate, you use a LAN-only gateway, such as Rithmic 01 Colo 75 or Rithmic Paper Trading Colo 75.</p>
<h3><a class="anchor" id="pg_connection_best_practices"></a>
Best Practices</h3>
<p>Because there are many Rithmic systems, each with multiple gateways, application developers often find that keeping connection point settings (i.e. the parameters to the REngine constructor and to REngine::login()) configurable, and outside of their application binary.</p>
<p>In this way, one can add support for new Rithmic systems and/or gateways with a configuration change, rather than rebuilding a binary.</p>
<h3><a class="anchor" id="pg_connection_mgmt"></a>
Connection Management</h3>
<p>Updates to the status of these connections are provided via RCallbacks::Alert() in R | API. The alert types associated with connections are : </p>
<ul>
<li>Connection Opened - a connection has been established. </li>
<li>Connection Broken - a connection has been broken or is in recovery. When a connection is broken, R | API will attempt to automatically recover the connection. Subscriptions will be resubmitted automatically as part of the recovery processing. </li>
<li>Connection Closed - a connection has been closed. </li>
<li>Quiet Heartbeat - a heartbeat was not detected. Heartbeats are used to verify the integrity of each connection. It is possible for the quiet heartbeat alert to fire on a good connection if the machine could not run the heartbeat detection routine in time (i.e. cpu too busy, stopped in debugger, etc.). </li>
<li>Login Complete - login credentials were received and accepted. </li>
<li>Login Failed - login credentials were received but not accepted. </li>
<li>Forced Logout - the session is about to be terminated because the maximum number of concurrent sessions of this user have been exceeded. If one connection receives a forced logout alert, the RAPI will log out from all connections in that login session. Users can ask their administrator to increase the maximum number of concurrent sessions.</li>
</ul>
<p>Quiet Heartbeat vs. Connection Broken Alerts</p>
<p>Sometimes a connection will go bad, but the operating system will continue waiting for some timeout period (perhaps optimistically, and perhaps in consideration of very low bandwidth or high latency network connections). In these cases where the connection is truly bad, but with the OS still waiting for the timeout, you may get one or more quiet heartbeat alerts. If (when?) the OS does end up concluding the connection is bad, it will inform the process, which will appear to you via the R | API as a connection broken event. Upon receiving a connection broken event, the R | API will automatically attempt to recover the connection. It will not attempt recovery upon receipt of a quiet heartbeat event. (FYI : It will also not attempt recovery when a login fails authentication either.)</p>
<p>Connecting During A System Reboot</p>
<p>The infrastructure has a schedule to reboot at regular maintenance intervals. Usually this will happen each weekend. When the infrastructure is brought down, R | API client connections to the infrastructure will be broken, triggering connection broken alerts. Although it is possible that the broken connections will recovery automatically and gracefully, it is also possible that a recovery attempt will result in a login failure, despite valid credentials being presented. This failure will happen when the connection points accept connections before the user id/authentication service is on-line. When authentication cannot be verified, login will fail by default. So, it may be necessary to re-initiate logging in after system reboots.</p>
<hr/>
<h2><a class="anchor" id="pg_strings_cpp"></a>
Strings And tsNCharcb (C++ Only)</h2>
<p>This section provides an overview of how the tsNCharcb data type is used.</p>
<h3><a class="anchor" id="pg_strings_why_tsncharcb"></a>
Why use the tsNCharcb for representing strings?</h3>
<p>The tsNCharcb is the standard string data structure native to the larger body of work used by Rithmic. It is a lightweight structure compatible with both C and C++ and is used by the libraries the R | API is written on.</p>
<p>Because it includes both a pointer and a length, many common operations can be done more efficiently than with char * strings. For example, when comparing strings, one can test the length of each string first, potentially saving a memory comparison call.</p>
<p>The C++ string type shares some of the characteristics and efficiencies of the tsNCharcb, but the tsNCharcb data structure and its associated body of work pre-date the C++ strings. As a result, the R | API also uses the tsNCharcb instead of the C++ string.</p>
<p>A tsNCharcb represents the absence of a value when the pData is equal to NULL and iDataLen is equal to 0 (zero). Sometimes we will refer to such a tsNCharcb as 'empty'.</p>
<p>When a routine has a pointer to a tsNCharcb as a parameter, and you do not wish to specify that parameter, you can set the pointer value to null, or the tsNCharcb members to null and zero.</p>
<p>When a routine asks for an array of tsNCharcbs, you should provide the array, with each array element being null or containing an empty tsNCharcb.</p>
<h3><a class="anchor" id="pg_strings_cpp_to_tsnchar"></a>
How does one convert a C++ string into a tsNCharcb?</h3>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">string</span>    strCpp;
     <a class="code" href="structsNCharcb.html" title="String structure used by the RApi. Typically appears in code as the typedef tsNCharcb.">tsNCharcb</a> sNChar;

     ...

     <span class="keywordflow">if</span> (strCpp.empty())
          {
          sNChar.<a class="code" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">pData</a>    = NULL;
          sNChar.<a class="code" href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">iDataLen</a> = 0;
          }
     <span class="keywordflow">else</span>
          {
          sNChar.<a class="code" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">pData</a>    = (<span class="keywordtype">char</span> *)strCpp.data();
          sNChar.<a class="code" href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">iDataLen</a> = strCpp.length();
          }
</pre></div><h3><a class="anchor" id="pg_strings_tsnchar_to_cpp"></a>
How does one convert a tsNCharcb into a C++ string?</h3>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">string</span>    strCpp;
     <a class="code" href="structsNCharcb.html" title="String structure used by the RApi. Typically appears in code as the typedef tsNCharcb.">tsNCharcb</a> sNChar;

     ...

     strCpp = string(sNChar.<a class="code" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">pData</a>, sNChar.<a class="code" href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">iDataLen</a>);
</pre></div><h3><a class="anchor" id="pg_strings_tsnchar_init"></a>
Do I need to initialize both the pData and the iDataLen of each tsNCharcb?</h3>
<p>Yes. The two should always be consistent. If the string is empty/undefined, the pData should be set to NULL, and the iDataLen should be set to 0 (zero).</p>
<p>If the two values are inconsistent, the behavior of the api is undefined. In the best case, you will get a response of API_BAD_INPUT for some call. In the worst case, your application's memory space will be 'corrupt'.</p>
<p>It is possible to have pData pointing to a legitimate buffer, with iDataLen set to zero.</p>
<h3><a class="anchor" id="pg_strings_memory"></a>
Who owns the memory pointed to by tsNCharcb::pData?</h3>
<p>Whoever allocated the memory is responsible for it. When passing tsNCharcb parameters to the R | API methods, the data will be copied within the method before returning. When the R | API invokes user-defined callbacks, the <a class="el" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">tsNCharcb::pData</a> memory will most likely become invalid immediately upon exiting the callback method, so if the values will be kept, they need to be copied.</p>
<hr/>
<h2><a class="anchor" id="pg_timestamps"></a>
On Timestamps (ssboe, usecs and nsecs)</h2>
<p>The Rithmic APIs make use of unix time conventions for timestamps. Unix time is the number of Seconds Since the Beginning Of the Epoch (ssboe). The epoch is defined to have begun on Jan 1, 1970 UTC (Universal Coordinated Time). One can find more detailed discussions on unix time on the Internet, as well as documentation on how one might convert unix time to/from other time formats using a variety of technologies.</p>
<p>There is often a microseconds (usecs) portion of the timestamp to accompany the ssboe value. Sometimes there is even a nanoseconds (nsecs) portion.</p>
<p>Both the ssboe, usecs and nsecs values are usually stored as integer types.</p>
<hr/>
<h2><a class="anchor" id="pg_threads"></a>
On Threads</h2>
<h3><a class="anchor" id="pg_threads_cpp"></a>
Threads In C++ API</h3>
<p>The C++ version of the Rithmic APIs will create an internal "worker" thread. Almost all of the callbacks will be invoked on this worker thread. The reason for this arrangement is because the methods exposed by REngine are typically handled asynchronously by distributed services. When the distributed service reponds to REngine's methods, the worker thread will invoke the appropriate callback. In this way the main thread is not blocked.</p>
<p>If you use multiple threads and mutexes in your application space, it is possible to deadlock, as R | API also uses mutexes internally. Generally, the Rithmic APIs will lock upon entry into an REngine method, as well as prior to invoking a user-defined callback. You can use the very mutex R | API uses by calling REngine::lock() and REngine::unlock() to avoid these deadlock situations preserving the order of the lock() calls in each thread.</p>
<h3><a class="anchor" id="pg_threads_dotnet"></a>
Threads In .NET API</h3>
<p>The .NET version of the Rithmic APIs creates multiple threads. Each persistent network connection will have an input thread as well as an output thread. There are other administrative threads which may also be created. The .NET APIs do not expose REngine::lock() and REngine::unlock() methods because thread management is done differently than in the C++ APIs.</p>
<hr/>
<h2><a class="anchor" id="pg_errors"></a>
Error Handling Conventions</h2>
<h3><a class="anchor" id="pg_error_codes"></a>
Error Codes</h3>
<p>All Rithmic APIs make use of the same set of integer error codes to convey information about error conditions. Rithmic APIs also make use of these same exception classes internally.</p>
<p>In C++, the set of error codes are defined in the RApi.h header file, starting with API_OK.</p>
<h3><a class="anchor" id="pg_exception_classes"></a>
Exception Classes</h3>
<p>The exception class is <a class="el" href="classOmneException.html" title="Exception class used by the RApi.">OmneException</a>. Error codes can be retrieved from exceptions using <a class="el" href="classOmneException.html#a8303a48112ee9f2d27446d5b5081689c">OmneException.getErrorCode()</a>.</p>
<h3><a class="anchor" id="pg_aicode_out_param"></a>
The 'aiCode' Out Parameter (C++ only)</h3>
<p>All C++ Rithmic API methods provide a return value (OK or NOT_OK, defined in RApi.h), where NOT_OK indicates an error condition. When an error is encountered, the aiCode 'out' parameter is set with the value of the appropriate error code.</p>
<h3><a class="anchor" id="pg_error_why"></a>
Why And Where Errors Might Occur</h3>
<p>Typically, an 'action' object such as REngine, requests services from the network, resulting in a callback method being invoked to convey the response. Errors can occur :</p>
<ul>
<li>Within the requesting method as it tries to form the request and send it to the infrastructure. In this case, the error will result in an error code returned directly from the method being called.</li>
</ul>
<ul>
<li>Within the infrastructure as it tries to service the request. In this case, the error code will be conveyed via the standard callback associated with the originating method and possibly RCallbacks::Alert(), depending on the severity of the error. The 'Info' classes have an iRpCode field when they need to convey an error status.</li>
</ul>
<ul>
<li>Within the API as it processes the response and invokes the appropriate callback. This case is similar to conveying errors encountered in the infrastructre. The error code will be conveyed via the standard callback associated with the originating method and possibly RCallbacks::Alert(), depending on the severity of the error.</li>
</ul>
<p>Constructors and destructors (caution when using with STL) may throw exceptions also.</p>
<p>Native exceptions being thrown from a Rithmic API method indicate unhandled exceptions.</p>
<h3><a class="anchor" id="pg_error_examples"></a>
Examples Of Errors</h3>
<ul>
<li>
<p class="startli">An example of an error encountered locally in the REngine is if one attempts to subscribe to market data without being logged in. The error code returned would be 11, or 'no handle', indicating that there was no handle for the market data connection.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Alerts are fired if a more serious error has been reported by R | Trade Execution Platform. An example would be an error code of 14, or 'unknown request'. This error code indicates that the service being requested is down or off-line.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When an expected error is returned by R | Trade Execution Platform, the response code of the 'Info' instance, which is passed to the callback method, will contain the corresponding error code. An example of this case would be if REngine::getRefData() were called for an invalid instrument. RCallbacks::RefData() would be called where RefDataInfo's response code would contain a value of 7, or 'no data'. In other words, R | Trade Execution Platform has no data on the instrument being referenced.</p>
<p class="endli">When an unexpected error is returned by R | Trade Execution Platform, an Alert is raised by RCallbacks::Alert(). The AlertInfo instance will contain information about the error. </p>
</li>
</ul>
<h3><a class="anchor" id="pg_errors_in_user_callbacks"></a>
Error Handling In User Implemented Callbacks</h3>
<p>When implementing a callback method in C++, the expectation is that the callback will return (OK), or return (NOT_OK) with the value of *aiCode set to API_IGNORED. If the callback method returns NOT_OK with a *aiCode value that is not API_IGNORED, the error will be interpretted as a grievous error and cause the connection associated with the callback to be broken. This should only be done when actually enountering a grievous error.</p>
<hr/>
<h2><a class="anchor" id="pg_basic_steps"></a>
Basic Steps of a Program that Incorporates R | API</h2>
<p>The following list presents the basic steps that a program that incorporates R | API must perform: </p>
<ul>
<li>Create an instance of AdmCallbacks. This implies that you have to define your own class, since AdmCallbacks is abstract. </li>
<li>Create and populate an instance of REngineParams. This set of parameters contains the configuration information needed to instantiate the REngine. Some of the configuration information will be retrieved from the environment (REngineParams::envp). Actual configuration values will be provided by the Rithmic operations team and may be specified in a configuration file (such as "uat_connection_params.txt") in your download directory. The naming conventions used in the operations document will loosely match the names in R | API interface. </li>
<li>Create an instance of the REngine, using the AdmCallbacks and REngineParams from above. The reason you need the AdmCallbacks is because you can receive administrative alerts without being logged in. </li>
<li>Create an instance of RCallbacks. Again, because it is an abstract class, you must derive your own subclass and implement it. Implementing all callbacks forces the user to explicitly handle or ignore the available callbacks. </li>
<li>Log in using REngine::login(). The methods invoked on the RCallbacks instance passed into the login call will correspond to this login session. </li>
<li>Wait for updates on the login status by examining the RCallbacks::Alert() callback. </li>
<li>If the login completes for all connect points, the program will be able to access the services of R | Trade Execution Platform. If any of the logins fail for any of the connect points, R | API will automatically log out of all connect points. In other words, each connect point has its own authentication handshake, and if one fails, they all fail. </li>
<li>Assuming a successful login, invoke methods on REngine, process responses in RCallbacks as necessary. </li>
<li>Logout. Note that REngine::logout() will automatically be called in the REngine destructor so this step is optional if you intend on destroying the REngine instance immediately. However, if you call REngine::logout() yourself, you can log back into R | Trade Execution Platform using the same instance of the REngine, but perhaps with different credentials. </li>
<li>Destroy the RCallbacks instance. You should not destroy the callbacks instance before logging out, as any of its methods may be called until the logout is complete. </li>
<li>Destroy the REngine instance. </li>
<li>Destroy the AdmCallbacks instance.</li>
</ul>
<hr/>
<h2><a class="anchor" id="pg_bug_reports"></a>
Feedback And Bug Reports</h2>
<p>We are always interested in hearing feedback regarding the API. This ranges from feature requests to bug reports to typos in the documentation.</p>
<hr/>
<h2><a class="anchor" id="pg_contact_info"></a>
Contact Info</h2>
<p>We can be reached at <a href="mailto:rapi@rithmic.com">rapi@rithmic.com</a>. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Jan 3 2021 13:44:02 for R | API+ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
